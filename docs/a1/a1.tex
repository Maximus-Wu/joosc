\documentclass[12pt, titlepage]{article}
%Packages
\usepackage{
  fancyhdr,
  indentfirst,
  lastpage,
  listings,
}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

% declare some useful macros
\newcommand{\assignmentNumber}{Assignment 1}
\newcommand{\courseName}{CS 444}

\lstset{basicstyle=\ttfamily}

\begin{document}
\pagestyle{fancyplain}
\thispagestyle{plain}

%Headers
\fancyhead{}
\fancyfoot{}
\rhead{\fancyplain{}{Page \thepage\ of \pageref{LastPage}}}
\chead{\fancyplain{}{\assignmentNumber}}
\lhead{\fancyplain{}{\courseName}}

\title{CS444 - \assignmentNumber\\Lexing, Parsing, and Weeding Documentation}
\date{\today}
\author{Alex Klen\\20372654\and Sanjay Menakuru\\20374915\and Jonathan Wei\\20376489}

\maketitle

\section{Architecture}
Here, we will discuss interesting aspects of our compiler's design and
implementation.

\subsection{Base}
Our `base' namespace has a number of common utilities and abstractions that are
used by every phase of the compiler.

We have a File abstraction that encapsulates a random-access array of bytes
with a directory name and a file name. We have two implementations of this
interface.

\begin{enumerate}
  \item
  We have an implementation of File backed by a C++ string, which is used for
  our unit tests.
  \item
  We have an disk-backed implementation of File, that uses the `mmap' system
  call to have fast random access into a file, without needing to load it into
  memory.
\end{enumerate}

We have two light-weight structs that help us refer to offsets and ranges
within files. These are called `Pos' and `PosRange', respectively.

We have a base class for all Error messages generated by the compiler. We
avoided the use of exceptions for errors, because they naturally lead to
compilers that only emit 1 fatal error at a time, and we had a goal of
generating user-friendly errors.

\subsection{Lexer}
Our lexer is essentially a small state machine that takes an input byte stream
and emits a stream of tokens. It is composed of lexing functions; each lexing
function can consume some input, emit a token, and set the state to a different
lexing function. Each emitted token contains both the token type as well as the
corresponding PosRange.

We have a lookup table for valid and reserved tokens in Java. It includes
entries like `++', `class', `final', and `if'. The table also includes
information about each kind of token; for example, it marks `-' as both a
binary and a unary operator, it marks `++' as unsupported, and it marks `if' as
a keyword.


\subsection{Parser}
We hand-wrote a recursive descent parser for Joos. We had two interesting
classes here, Parser and Result. Parser is immutable and contains a reference
to a stream of token and an index into that stream. Parser has methods that
parse productions in our grammar and return a new Parser. Instances of the
Result class are produced from Parser methods, and contain AST nodes. Both
Parser and Result have a notion of an error state, allowing chained parsing
method-calls to short-circuit on failure. This design allows easy chaining of
parsers to build higher-level parsers. For instance, here is a snippet from the
parsing of the `while' statement.
\begin{lstlisting}[language=c++]
Result<Token> whileTok;
Result<Token> lparen;
Result<Expr> cond;
Result<Token> rparen;
Result<Stmt> body;

Parser after = (*this)
  .ParseTokenIf(ExactType(K_WHILE), &whileTok)
  .ParseTokenIf(ExactType(LPAREN), &lparen)
  .ParseExpression(&cond)
  .ParseTokenIf(ExactType(RPAREN), &rparen)
  .ParseStmt(&body);
\end{lstlisting}

We also have a function that will propogate errors correctly from such a
chained statement. It will take the first non-empty ErrorList as the overall
error from parsing the while statement.
\begin{lstlisting}[language=c++]
ErrorList errors;
FirstOf(&errors, &whileTok, &lparen, &cond, &rparen, &body);
return Fail(move(errors), out);
\end{lstlisting}

\subsubsection{Abstract Syntax Tree}
We wrote a fairly standard AST for Joos, which our parser generates directly.
For instance, this is the AST node for the while statement.
\begin{lstlisting}[language=c++]
class WhileStmt: public Stmt {
public:
  WhileStmt(Expr* cond, Stmt* body): cond_(cond), body_(body) {}

  const Expr* Cond() const { return cond_.get(); }
  const Stmt* Body() const { return body_.get(); }

private:
  DISALLOW_COPY_AND_ASSIGN(WhileStmt);

  unique_ptr<Expr> cond_;
  unique_ptr<Stmt> body_; // May be EmptyStmt.
};
\end{lstlisting}

\subsubsection{Grammar}
We wrote a grammar based on the Second Edition of the Java Language
Specification (JLS). We heavily modified the grammar to be more concise and to
be unambiguously parsable by a top-down recursive-descent parser. We removed
all of the immediate left-recursion and we simplified the rules to more closely
match our AST nodes. To continue with our running example, here is our
production rule for while statements.
\begin{lstlisting}
WhileStatement:
  "while" "(" Expression ")" Statement
\end{lstlisting}

\subsection{Visitors}
All of our AST nodes support the Visitor pattern. We used the Visitor pattern
extensively in the Weeder and to implement a pretty-printer for our AST. In
addition to our base Visitor, we also have a subclass named RecursiveVisitor
that automatically recurses through the entire AST. Visitors that only need to
examine particular nodes in the AST (method calls, for instance) must only
override the required methods, and the RecursiveVisitor will take care of
reaching every node.To continue our running example, here is the pretty-printer
implementation for the while statement.
\begin{lstlisting}[language=c++]
VISIT_DECL(WhileStmt, stmt) {
  *os_ << "while" << space_ << '(';
  stmt->Cond()->Accept(this);
  *os_ << ')' << space_ << '{';
  stmt->Body()->Accept(this);
  *os_ << '}';
}
\end{lstlisting}

\subsection{Weeder}
The weeder consists of a series of Visitor implementations. We have
implementations that check various restrictions of the Joos language that were
difficult to enforce in the parser. For example, we check that modifier lists
have no contradictions, and that members are either public or protected.

\section{Challenges}
\subsection{Memory Management}
\subsection{Precedence and Associativity}
\subsection{Integer range checking}

\section{Testing}

\end{document}

