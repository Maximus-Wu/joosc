\documentclass[12pt, titlepage]{article}
%Packages
\usepackage{
  fancyhdr,
  indentfirst,
  lastpage,
}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

% declare some useful macros
\newcommand{\assignmentNumber}{Assignment 1}
\newcommand{\courseName}{CS 444}

\begin{document}
\pagestyle{fancyplain}
\thispagestyle{plain}

%Headers
\fancyhead{}
\fancyfoot{}
\rhead{\fancyplain{}{Page \thepage\ of \pageref{LastPage}}}
\chead{\fancyplain{}{\assignmentNumber}}
\lhead{\fancyplain{}{\courseName}}

\title{CS444 - \assignmentNumber\\Lexing, Parsing, and Weeding Documentation}
\date{\today}
\author{Alex Klen\\20372654\and Sanjay Menakuru\\20374915\and Jonathan Wei\\20376489}

\maketitle

\section{Architecture}
Here, we will discuss interesting aspects of our compiler's design and
implementation.

\subsection{Base}
Our `base' namespace has a number of common utilities and abstractions that are
used by every phase of the compiler.

We have a File abstraction that encapsulates a random-access array of bytes
with a directory name and a file name. We have two implementations of this
interface.

\begin{enumerate}
  \item
  We have an implementation of File backed by a C++ string, which is used for
  our unit tests.
  \item
  We have an disk-backed implementation of File, that uses the `mmap' system
  call to have fast random access into a file, without needing to load it into
  memory.
\end{enumerate}

We have two light-weight structs that help us refer to offsets and ranges
within files. These are called `Pos' and `PosRange', respectively.

We have a base class for all Error messages generated by the compiler. We
avoided the use of exceptions for errors, because they naturally lead to
compilers that only emit 1 fatal error at a time, and we had a goal of
generating user-friendly errors.

\subsection{Lexer}
Our lexer is essentially a small state machine that takes an input byte stream
and emits a stream of tokens. It is composed of lexing functions; each lexing
function can consume some input, emit a token, and set the state to a different
lexing function. Each emitted token contains both the token type as well as the
corresponding PosRange.

We have a lookup table for valid and reserved tokens in Java. It includes
entries like `++', `class', `final', and `if'. The table also includes
information about each kind of token; for example, it marks `-' as both a
binary and a unary operator, it marks `++' as unsupported, and it marks `if' as
a keyword.

\subsection{Abstract Syntax Tree}
% TODO

\subsection{Parser}


\subsubsection{Grammar}
We wrote a grammar based on the Second Edition of the Java Language
Specification (JLS). We heavily modified the grammar to be more concise and to
be unambiguously parsable by a top-down recursive-descent parser. We removed
all of the immediate left-recursion and we simplified the rules to more closely
match our AST nodes.

\subsection{Visitors}

\subsection{Weeder}

\section{Challenges}

\section{Testing}

\end{document}

